# 1. Какой самый эффективный способ конкатенации строк?

### Объяснения результатов бенчмарков

#### Таблица 1: `plus_wins` 

Однократная конкатенация небольшого количества коротких строк.

| Бенчмарк               | ns/op  | B/op  | allocs/op |
|------------------------|--------|-------|-----------|
| BenchmarkConcatPlus    | 0.4081 | 0     | 0         |
| BenchmarkConcatJoin    | 75.49  | 32    | 1         |
| BenchmarkConcatBuffer  | 96.88  | 64    | 1         |
| BenchmarkConcatBuilder | 90.89  | 56    | 3         |

```go
for i := 0; i < b.N; i++ {
		result := "This" + " " + "is" + " " + "a" + " " + "test" + " " + "of" + " " + "the" + " " + "buffer."
		_ = result
}
```
В этом сценарии бенчмарков, где тестировались методы конкатенации небольших строк, оператор `+` занимает первое место по времени выполнения. 

Это связано с тем, что Go оптимизирует операции сложения строк, особенно когда они выполняются в локальном контексте и для небольшого числа строк. 

В подобных случаях строки просто соединяются в результате компиляции без лишних затрат на управление памятью или выделение новых буферов.

#### Таблица 2: `join_wins`

Конкатенация большого массива строк.

| Бенчмарк               | ns/op     | B/op      | allocs/op |
|------------------------|-----------|-----------|-----------|
| BenchmarkConcatJoin    | 22179     | 106496    | 1         |
| BenchmarkConcatBuffer  | 58339     | 368018    | 12        |
| BenchmarkConcatBuilder | 72224     | 513553    | 20        |

```go
largeParts := generateLargeSlice(1000, 100) // 1000 строк по 100 символов
for i := 0; i < b.N; i++ {
    _ = strings.Join(largeParts, " ")
}
```
`strings.Join` оптимально работает, когда известна длина массива строк, которые нужно объединить, поскольку он позволяет Go заранее выделить необходимое количество памяти для результирующей строки. Это минимизирует количество перераспределений памяти, что значительно улучшает производительность. Это эффективно в сценариях, когда есть заранее известный массив строк фиксированной длины, которые нужно объединить в одну строку. 

Этот метод справляется с большими объемами данных, обеспечивая быстрый доступ и минимальные затраты на аллокацию памяти.

#### Таблица 3: `buff_wins`

Сценарий динамической конкатенации, где число сток неизвестно заранее.

| Бенчмарк                       | ns/op  | B/op  | allocs/op |
|--------------------------------|--------|-------|-----------|
| BenchmarkConditionalBuilder    | 71148  | 30612 | 1748      |
| BenchmarkConditionalBuffer     | 69385  | 34406 | 1744      |
| BenchmarkConditionalJoin       | 83064  | 83656 | 1738      |

В сценарии конкатенации строк с условным форматированием, `bytes.Buffer` демонстрирует наилучшую производительность по времени, но при этом потребляет больше памяти, чем `strings.Builder`, который показывает схожую производительность по времени, но более эффективно использует память.

Поскольку разница по скорости минимальна, а по памяти ощутима, `strings.Builder` наиболее предпочтителен при работе в сценариях с динамическими строками.

### Итого

Нельзя сказать что какой-то метод однозначно бьёт другие по производительности, поскольку всё зависит от контекста использования данного метода.
При эпизодических однократных конкатенациях лучше всего подходит оператор `+`
`join` наиболее эффективен при конкатенации заранее известного массива.
`Builder` и `Buffer` лучше всего себя показали при динамическом выделении памяти.

